
C:\Users\person\AppData\Local\Temp\arduino\sketches\088D3AE83322C34C72994898D78FE7B3/tiny-dungeon.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	43 c1       	rjmp	.+646    	; 0x288 <__ctors_end>
   2:	52 c1       	rjmp	.+676    	; 0x2a8 <__bad_interrupt>
   4:	51 c1       	rjmp	.+674    	; 0x2a8 <__bad_interrupt>
   6:	50 c1       	rjmp	.+672    	; 0x2a8 <__bad_interrupt>
   8:	4f c1       	rjmp	.+670    	; 0x2a8 <__bad_interrupt>
   a:	4e c1       	rjmp	.+668    	; 0x2a8 <__bad_interrupt>
   c:	4d c1       	rjmp	.+666    	; 0x2a8 <__bad_interrupt>
   e:	4c c1       	rjmp	.+664    	; 0x2a8 <__bad_interrupt>
  10:	4b c1       	rjmp	.+662    	; 0x2a8 <__bad_interrupt>
  12:	4a c1       	rjmp	.+660    	; 0x2a8 <__bad_interrupt>
  14:	49 c1       	rjmp	.+658    	; 0x2a8 <__bad_interrupt>
  16:	48 c1       	rjmp	.+656    	; 0x2a8 <__bad_interrupt>
  18:	47 c1       	rjmp	.+654    	; 0x2a8 <__bad_interrupt>
  1a:	46 c1       	rjmp	.+652    	; 0x2a8 <__bad_interrupt>
  1c:	45 c1       	rjmp	.+650    	; 0x2a8 <__bad_interrupt>
  1e:	49 c3       	rjmp	.+1682   	; 0x6b2 <__vector_15>
  20:	ce c2       	rjmp	.+1436   	; 0x5be <__vector_16>

00000022 <__trampolines_end>:
	...
__trampolines_start():
  2a:	5f 00       	.word	0x005f	; ????
  2c:	00 00       	nop
  2e:	00 07       	cpc	r16, r16
  30:	00 07       	cpc	r16, r16
  32:	00 00       	nop
  34:	14 7f       	andi	r17, 0xF4	; 244
  36:	14 7f       	andi	r17, 0xF4	; 244
  38:	14 00       	.word	0x0014	; ????
  3a:	24 2a       	or	r2, r20
  3c:	7f 2a       	or	r7, r31
  3e:	12 00       	.word	0x0012	; ????
  40:	23 13       	cpse	r18, r19
  42:	08 64       	ori	r16, 0x48	; 72
  44:	62 00       	.word	0x0062	; ????
  46:	36 49       	sbci	r19, 0x96	; 150
  48:	56 20       	and	r5, r6
  4a:	50 00       	.word	0x0050	; ????
  4c:	00 08       	sbc	r0, r0
  4e:	07 03       	mulsu	r16, r23
  50:	00 00       	nop
  52:	00 1c       	adc	r0, r0
  54:	22 41       	sbci	r18, 0x12	; 18
  56:	00 00       	nop
  58:	00 41       	sbci	r16, 0x10	; 16
  5a:	22 1c       	adc	r2, r2
  5c:	00 00       	nop
  5e:	2a 1c       	adc	r2, r10
  60:	7f 1c       	adc	r7, r15
  62:	2a 00       	.word	0x002a	; ????
  64:	08 08       	sbc	r0, r8
  66:	3e 08       	sbc	r3, r14
  68:	08 00       	.word	0x0008	; ????
  6a:	00 80       	ld	r0, Z
  6c:	70 30       	cpi	r23, 0x00	; 0
  6e:	00 00       	nop
  70:	08 08       	sbc	r0, r8
  72:	08 08       	sbc	r0, r8
  74:	08 00       	.word	0x0008	; ????
  76:	00 00       	nop
  78:	60 60       	ori	r22, 0x00	; 0
  7a:	00 00       	nop
  7c:	20 10       	cpse	r2, r0
  7e:	08 04       	cpc	r0, r8
  80:	02 00       	.word	0x0002	; ????
  82:	3e 51       	subi	r19, 0x1E	; 30
  84:	49 45       	sbci	r20, 0x59	; 89
  86:	3e 00       	.word	0x003e	; ????
  88:	00 42       	sbci	r16, 0x20	; 32
  8a:	7f 40       	sbci	r23, 0x0F	; 15
  8c:	00 00       	nop
  8e:	72 49       	sbci	r23, 0x92	; 146
  90:	49 49       	sbci	r20, 0x99	; 153
  92:	46 00       	.word	0x0046	; ????
  94:	21 41       	sbci	r18, 0x11	; 17
  96:	49 4d       	sbci	r20, 0xD9	; 217
  98:	33 00       	.word	0x0033	; ????
  9a:	18 14       	cp	r1, r8
  9c:	12 7f       	andi	r17, 0xF2	; 242
  9e:	10 00       	.word	0x0010	; ????
  a0:	27 45       	sbci	r18, 0x57	; 87
  a2:	45 45       	sbci	r20, 0x55	; 85
  a4:	39 00       	.word	0x0039	; ????
  a6:	3c 4a       	sbci	r19, 0xAC	; 172
  a8:	49 49       	sbci	r20, 0x99	; 153
  aa:	31 00       	.word	0x0031	; ????
  ac:	41 21       	and	r20, r1
  ae:	11 09       	sbc	r17, r1
  b0:	07 00       	.word	0x0007	; ????
  b2:	36 49       	sbci	r19, 0x96	; 150
  b4:	49 49       	sbci	r20, 0x99	; 153
  b6:	36 00       	.word	0x0036	; ????
  b8:	46 49       	sbci	r20, 0x96	; 150
  ba:	49 29       	or	r20, r9
  bc:	1e 00       	.word	0x001e	; ????
  be:	00 00       	nop
  c0:	14 00       	.word	0x0014	; ????
  c2:	00 00       	nop
  c4:	00 40       	sbci	r16, 0x00	; 0
  c6:	34 00       	.word	0x0034	; ????
  c8:	00 00       	nop
  ca:	00 08       	sbc	r0, r0
  cc:	14 22       	and	r1, r20
  ce:	41 00       	.word	0x0041	; ????
  d0:	14 14       	cp	r1, r4
  d2:	14 14       	cp	r1, r4
  d4:	14 00       	.word	0x0014	; ????
  d6:	00 41       	sbci	r16, 0x10	; 16
  d8:	22 14       	cp	r2, r2
  da:	08 00       	.word	0x0008	; ????
  dc:	02 01       	movw	r0, r4
  de:	59 09       	sbc	r21, r9
  e0:	06 00       	.word	0x0006	; ????
  e2:	3e 41       	sbci	r19, 0x1E	; 30
  e4:	5d 59       	subi	r21, 0x9D	; 157
  e6:	4e 00       	.word	0x004e	; ????
  e8:	7c 12       	cpse	r7, r28
  ea:	11 12       	cpse	r1, r17
  ec:	7c 00       	.word	0x007c	; ????
  ee:	7f 49       	sbci	r23, 0x9F	; 159
  f0:	49 49       	sbci	r20, 0x99	; 153
  f2:	36 00       	.word	0x0036	; ????
  f4:	3e 41       	sbci	r19, 0x1E	; 30
  f6:	41 41       	sbci	r20, 0x11	; 17
  f8:	22 00       	.word	0x0022	; ????
  fa:	7f 41       	sbci	r23, 0x1F	; 31
  fc:	41 41       	sbci	r20, 0x11	; 17
  fe:	3e 00       	.word	0x003e	; ????
 100:	7f 49       	sbci	r23, 0x9F	; 159
 102:	49 49       	sbci	r20, 0x99	; 153
 104:	41 00       	.word	0x0041	; ????
 106:	7f 09       	sbc	r23, r15
 108:	09 09       	sbc	r16, r9
 10a:	01 00       	.word	0x0001	; ????
 10c:	3e 41       	sbci	r19, 0x1E	; 30
 10e:	41 51       	subi	r20, 0x11	; 17
 110:	73 00       	.word	0x0073	; ????
 112:	7f 08       	sbc	r7, r15
 114:	08 08       	sbc	r0, r8
 116:	7f 00       	.word	0x007f	; ????
 118:	00 41       	sbci	r16, 0x10	; 16
 11a:	7f 41       	sbci	r23, 0x1F	; 31
 11c:	00 00       	nop
 11e:	20 40       	sbci	r18, 0x00	; 0
 120:	41 3f       	cpi	r20, 0xF1	; 241
 122:	01 00       	.word	0x0001	; ????
 124:	7f 08       	sbc	r7, r15
 126:	14 22       	and	r1, r20
 128:	41 00       	.word	0x0041	; ????
 12a:	7f 40       	sbci	r23, 0x0F	; 15
 12c:	40 40       	sbci	r20, 0x00	; 0
 12e:	40 00       	.word	0x0040	; ????
 130:	7f 02       	muls	r23, r31
 132:	1c 02       	muls	r17, r28
 134:	7f 00       	.word	0x007f	; ????
 136:	7f 04       	cpc	r7, r15
 138:	08 10       	cpse	r0, r8
 13a:	7f 00       	.word	0x007f	; ????
 13c:	3e 41       	sbci	r19, 0x1E	; 30
 13e:	41 41       	sbci	r20, 0x11	; 17
 140:	3e 00       	.word	0x003e	; ????
 142:	7f 09       	sbc	r23, r15
 144:	09 09       	sbc	r16, r9
 146:	06 00       	.word	0x0006	; ????
 148:	3e 41       	sbci	r19, 0x1E	; 30
 14a:	51 21       	and	r21, r1
 14c:	5e 00       	.word	0x005e	; ????
 14e:	7f 09       	sbc	r23, r15
 150:	19 29       	or	r17, r9
 152:	46 00       	.word	0x0046	; ????
 154:	26 49       	sbci	r18, 0x96	; 150
 156:	49 49       	sbci	r20, 0x99	; 153
 158:	32 00       	.word	0x0032	; ????
 15a:	03 01       	movw	r0, r6
 15c:	7f 01       	movw	r14, r30
 15e:	03 00       	.word	0x0003	; ????
 160:	3f 40       	sbci	r19, 0x0F	; 15
 162:	40 40       	sbci	r20, 0x00	; 0
 164:	3f 00       	.word	0x003f	; ????
 166:	1f 20       	and	r1, r15
 168:	40 20       	and	r4, r0
 16a:	1f 00       	.word	0x001f	; ????
 16c:	3f 40       	sbci	r19, 0x0F	; 15
 16e:	38 40       	sbci	r19, 0x08	; 8
 170:	3f 00       	.word	0x003f	; ????
 172:	63 14       	cp	r6, r3
 174:	08 14       	cp	r0, r8
 176:	63 00       	.word	0x0063	; ????
 178:	03 04       	cpc	r0, r3
 17a:	78 04       	cpc	r7, r8
 17c:	03 00       	.word	0x0003	; ????
 17e:	61 59       	subi	r22, 0x91	; 145
 180:	49 4d       	sbci	r20, 0xD9	; 217
 182:	43 00       	.word	0x0043	; ????
 184:	00 7f       	andi	r16, 0xF0	; 240
 186:	41 41       	sbci	r20, 0x11	; 17
 188:	41 00       	.word	0x0041	; ????
 18a:	02 04       	cpc	r0, r2
 18c:	08 10       	cpse	r0, r8
 18e:	20 00       	.word	0x0020	; ????
 190:	00 41       	sbci	r16, 0x10	; 16
 192:	41 41       	sbci	r20, 0x11	; 17
 194:	7f 00       	.word	0x007f	; ????
 196:	04 02       	muls	r16, r20
 198:	01 02       	muls	r16, r17
 19a:	04 00       	.word	0x0004	; ????
 19c:	40 40       	sbci	r20, 0x00	; 0
 19e:	40 40       	sbci	r20, 0x00	; 0
 1a0:	40 00       	.word	0x0040	; ????
 1a2:	00 03       	mulsu	r16, r16
 1a4:	07 08       	sbc	r0, r7
 1a6:	00 00       	nop
 1a8:	20 54       	subi	r18, 0x40	; 64
 1aa:	54 78       	andi	r21, 0x84	; 132
 1ac:	40 00       	.word	0x0040	; ????
 1ae:	7f 28       	or	r7, r15
 1b0:	44 44       	sbci	r20, 0x44	; 68
 1b2:	38 00       	.word	0x0038	; ????
 1b4:	38 44       	sbci	r19, 0x48	; 72
 1b6:	44 44       	sbci	r20, 0x44	; 68
 1b8:	28 00       	.word	0x0028	; ????
 1ba:	38 44       	sbci	r19, 0x48	; 72
 1bc:	44 28       	or	r4, r4
 1be:	7f 00       	.word	0x007f	; ????
 1c0:	38 54       	subi	r19, 0x48	; 72
 1c2:	54 54       	subi	r21, 0x44	; 68
 1c4:	18 00       	.word	0x0018	; ????
 1c6:	00 08       	sbc	r0, r0
 1c8:	7e 09       	sbc	r23, r14
 1ca:	02 00       	.word	0x0002	; ????
 1cc:	18 a4       	ldd	r1, Y+40	; 0x28
 1ce:	a4 9c       	mul	r10, r4
 1d0:	78 00       	.word	0x0078	; ????
 1d2:	7f 08       	sbc	r7, r15
 1d4:	04 04       	cpc	r0, r4
 1d6:	78 00       	.word	0x0078	; ????
 1d8:	00 44       	sbci	r16, 0x40	; 64
 1da:	7d 40       	sbci	r23, 0x0D	; 13
 1dc:	00 00       	nop
 1de:	20 40       	sbci	r18, 0x00	; 0
 1e0:	40 3d       	cpi	r20, 0xD0	; 208
 1e2:	00 00       	nop
 1e4:	7f 10       	cpse	r7, r15
 1e6:	28 44       	sbci	r18, 0x48	; 72
 1e8:	00 00       	nop
 1ea:	00 41       	sbci	r16, 0x10	; 16
 1ec:	7f 40       	sbci	r23, 0x0F	; 15
 1ee:	00 00       	nop
 1f0:	7c 04       	cpc	r7, r12
 1f2:	78 04       	cpc	r7, r8
 1f4:	78 00       	.word	0x0078	; ????
 1f6:	7c 08       	sbc	r7, r12
 1f8:	04 04       	cpc	r0, r4
 1fa:	78 00       	.word	0x0078	; ????
 1fc:	38 44       	sbci	r19, 0x48	; 72
 1fe:	44 44       	sbci	r20, 0x44	; 68
 200:	38 00       	.word	0x0038	; ????
 202:	fc 18       	sub	r15, r12
 204:	24 24       	eor	r2, r4
 206:	18 00       	.word	0x0018	; ????
 208:	18 24       	eor	r1, r8
 20a:	24 18       	sub	r2, r4
 20c:	fc 00       	.word	0x00fc	; ????
 20e:	7c 08       	sbc	r7, r12
 210:	04 04       	cpc	r0, r4
 212:	08 00       	.word	0x0008	; ????
 214:	48 54       	subi	r20, 0x48	; 72
 216:	54 54       	subi	r21, 0x44	; 68
 218:	24 00       	.word	0x0024	; ????
 21a:	04 04       	cpc	r0, r4
 21c:	3f 44       	sbci	r19, 0x4F	; 79
 21e:	24 00       	.word	0x0024	; ????
 220:	3c 40       	sbci	r19, 0x0C	; 12
 222:	40 20       	and	r4, r0
 224:	7c 00       	.word	0x007c	; ????
 226:	1c 20       	and	r1, r12
 228:	40 20       	and	r4, r0
 22a:	1c 00       	.word	0x001c	; ????
 22c:	3c 40       	sbci	r19, 0x0C	; 12
 22e:	30 40       	sbci	r19, 0x00	; 0
 230:	3c 00       	.word	0x003c	; ????
 232:	44 28       	or	r4, r4
 234:	10 28       	or	r1, r0
 236:	44 00       	.word	0x0044	; ????
 238:	4c 90       	ld	r4, X
 23a:	90 90 7c 00 	lds	r9, 0x007C	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
 23e:	44 64       	ori	r20, 0x44	; 68
 240:	54 4c       	sbci	r21, 0xC4	; 196
 242:	44 00       	.word	0x0044	; ????
 244:	00 08       	sbc	r0, r0
 246:	36 41       	sbci	r19, 0x16	; 22
 248:	00 00       	nop
 24a:	00 00       	nop
 24c:	77 00       	.word	0x0077	; ????
 24e:	00 00       	nop
 250:	00 41       	sbci	r16, 0x10	; 16
 252:	36 08       	sbc	r3, r6
 254:	00 00       	nop
 256:	00 06       	cpc	r0, r16
 258:	09 06       	cpc	r0, r25
 25a:	00 00       	nop
 25c:	ff ff       	.word	0xffff	; ????
 25e:	ff ff       	.word	0xffff	; ????
 260:	ff 00       	.word	0x00ff	; ????

00000262 <testStack(unsigned long)::__c>:
 262:	41 00                                               A.

00000264 <debugStack()::__c>:
 264:	50 52 45 53 53 20 41 4e 59 20 46 4f 52 20 41 4e     PRESS ANY FOR AN
 274:	20 41 00                                             A.

00000277 <debugStack()::__c>:
 277:	53 54 41 43 4b 20 53 49 5a 45 20 54 45 53 54 00     STACK SIZE TEST.
	...

00000288 <__ctors_end>:
__dtors_end():
 288:	11 24       	eor	r1, r1
 28a:	1f be       	out	0x3f, r1	; 63
 28c:	cf e5       	ldi	r28, 0x5F	; 95
 28e:	d2 e0       	ldi	r29, 0x02	; 2
 290:	de bf       	out	0x3e, r29	; 62
 292:	cd bf       	out	0x3d, r28	; 61

00000294 <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
 294:	20 e0       	ldi	r18, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
 296:	a0 e6       	ldi	r26, 0x60	; 96
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
 298:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
 29a:	01 c0       	rjmp	.+2      	; 0x29e <.do_clear_bss_start>

0000029c <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
 29c:	1d 92       	st	X+, r1

0000029e <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
 29e:	ad 38       	cpi	r26, 0x8D	; 141
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
 2a0:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
 2a2:	e1 f7       	brne	.-8      	; 0x29c <.do_clear_bss_loop>
.do_clear_bss_start():
 2a4:	1f d2       	rcall	.+1086   	; 0x6e4 <main>
 2a6:	c6 c2       	rjmp	.+1420   	; 0x834 <_exit>

000002a8 <__bad_interrupt>:
__vector_1():
 2a8:	ab ce       	rjmp	.-682    	; 0x0 <__vectors>

000002aa <TwoWire::write(unsigned char) [clone .constprop.8]>:
_ZN7TwoWire5writeEh.constprop.8():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:507

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data) {
  if (transmitting) { // in master transmitter mode
 2aa:	90 91 8a 00 	lds	r25, 0x008A	; 0x80008a <TwoWire::transmitting>
 2ae:	99 23       	and	r25, r25
 2b0:	a1 f0       	breq	.+40     	; 0x2da <TwoWire::write(unsigned char) [clone .constprop.8]+0x30>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:509
    // don't bother if buffer is full
    if (BufferLength >= TWI_BUFFER_SIZE) {
 2b2:	90 91 8c 00 	lds	r25, 0x008C	; 0x80008c <TwoWire::BufferLength>
 2b6:	90 32       	cpi	r25, 0x20	; 32
 2b8:	40 f5       	brcc	.+80     	; 0x30a <TwoWire::write(unsigned char) [clone .constprop.8]+0x60>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:513
      return 0;
    }
    // put byte in tx buffer
    Buffer[BufferIndex] = data;
 2ba:	90 91 8b 00 	lds	r25, 0x008B	; 0x80008b <TwoWire::BufferIndex>
 2be:	e9 2f       	mov	r30, r25
 2c0:	f0 e0       	ldi	r31, 0x00	; 0
 2c2:	e0 5a       	subi	r30, 0xA0	; 160
 2c4:	ff 4f       	sbci	r31, 0xFF	; 255
 2c6:	80 83       	st	Z, r24
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:514
    ++BufferIndex;
 2c8:	81 e0       	ldi	r24, 0x01	; 1
 2ca:	89 0f       	add	r24, r25
 2cc:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <TwoWire::BufferIndex>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:516
    // update amount in buffer
    BufferLength = BufferIndex;
 2d0:	80 93 8c 00 	sts	0x008C, r24	; 0x80008c <TwoWire::BufferLength>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:525
      return 0;
    }
    // reply to master
    USI_TWI_Transmit_Byte(data);
  }
  return 1;
 2d4:	81 e0       	ldi	r24, 0x01	; 1
 2d6:	90 e0       	ldi	r25, 0x00	; 0
 2d8:	08 95       	ret
USI_TWI_Space_In_Transmission_Buffer():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:144

// Check if there is space in the transmission buffer.
unsigned char USI_TWI_Space_In_Transmission_Buffer(void)
{
  unsigned char tmpTxHead;
  tmpTxHead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate next buffer index.
 2da:	20 91 88 00 	lds	r18, 0x0088	; 0x800088 <TWI_TxHead>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:145
  return (TWI_TxTail - tmpTxHead) & TWI_TX_BUFFER_MASK; // Return 0 (FALSE) if the transmission buffer is full.
 2de:	90 91 87 00 	lds	r25, 0x0087	; 0x800087 <TWI_TxTail>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:144

// Check if there is space in the transmission buffer.
unsigned char USI_TWI_Space_In_Transmission_Buffer(void)
{
  unsigned char tmpTxHead;
  tmpTxHead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate next buffer index.
 2e2:	2f 5f       	subi	r18, 0xFF	; 255
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:145
  return (TWI_TxTail - tmpTxHead) & TWI_TX_BUFFER_MASK; // Return 0 (FALSE) if the transmission buffer is full.
 2e4:	92 1b       	sub	r25, r18
 2e6:	9f 70       	andi	r25, 0x0F	; 15
_ZN7TwoWire5writeEh.constprop.8():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:519
    ++BufferIndex;
    // update amount in buffer
    BufferLength = BufferIndex;
  } else { // in slave send mode
    // don't bother if buffer is full
    if (!USI_TWI_Space_In_Transmission_Buffer()) {
 2e8:	81 f0       	breq	.+32     	; 0x30a <TwoWire::write(unsigned char) [clone .constprop.8]+0x60>
USI_TWI_Transmit_Byte():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:100
// Puts data in the transmission buffer, Waits if buffer is full.
void USI_TWI_Transmit_Byte(unsigned char data)
{
  unsigned char tmphead;

  tmphead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate buffer index.
 2ea:	90 91 88 00 	lds	r25, 0x0088	; 0x800088 <TWI_TxHead>
 2ee:	9f 5f       	subi	r25, 0xFF	; 255
 2f0:	9f 70       	andi	r25, 0x0F	; 15
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:101
  while (tmphead == TWI_TxTail)
 2f2:	20 91 87 00 	lds	r18, 0x0087	; 0x800087 <TWI_TxTail>
 2f6:	92 17       	cp	r25, r18
 2f8:	e1 f3       	breq	.-8      	; 0x2f2 <TwoWire::write(unsigned char) [clone .constprop.8]+0x48>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:103
    ;                         // Wait for free space in buffer.
  TWI_TxBuf[tmphead] = data;    // Store data in buffer.
 2fa:	e9 2f       	mov	r30, r25
 2fc:	f0 e0       	ldi	r31, 0x00	; 0
 2fe:	e0 59       	subi	r30, 0x90	; 144
 300:	ff 4f       	sbci	r31, 0xFF	; 255
 302:	80 83       	st	Z, r24
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:104
  TWI_TxHead         = tmphead; // Store new index.
 304:	90 93 88 00 	sts	0x0088, r25	; 0x800088 <TWI_TxHead>
 308:	e5 cf       	rjmp	.-54     	; 0x2d4 <TwoWire::write(unsigned char) [clone .constprop.8]+0x2a>
_ZN7TwoWire5writeEh.constprop.8():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:510
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data) {
  if (transmitting) { // in master transmitter mode
    // don't bother if buffer is full
    if (BufferLength >= TWI_BUFFER_SIZE) {
      return 0;
 30a:	90 e0       	ldi	r25, 0x00	; 0
 30c:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:526
    }
    // reply to master
    USI_TWI_Transmit_Byte(data);
  }
  return 1;
}
 30e:	08 95       	ret

00000310 <TwoWire::write(int) [clone .constprop.7]>:
_ZN7TwoWire5writeEi.constprop.7():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.h:157
    uint8_t isActive(void);

    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
 310:	cc cf       	rjmp	.-104    	; 0x2aa <TwoWire::write(unsigned char) [clone .constprop.8]>

00000312 <TwoWire::beginTransmission(unsigned char) [clone .constprop.6]>:
_ZN7TwoWire17beginTransmissionEh.constprop.6():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:462
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)sendStop);
}

void TwoWire::beginTransmission(uint8_t address) {
  // indicate that we are transmitting
  transmitting = 1;
 312:	91 e0       	ldi	r25, 0x01	; 1
 314:	90 93 8a 00 	sts	0x008A, r25	; 0x80008a <TwoWire::transmitting>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:464
  // set address of targeted slave and write mode
  Buffer[0] = (address << TWI_ADR_BITS) | (0 << TWI_READ_BIT);
 318:	88 0f       	add	r24, r24
 31a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:466
  // reset tx buffer iterator vars
  BufferIndex = 1; // reserved by slave address
 31e:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <TwoWire::BufferIndex>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:467
  BufferLength = BufferIndex;
 322:	90 93 8c 00 	sts	0x008C, r25	; 0x80008c <TwoWire::BufferLength>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:468
}
 326:	08 95       	ret

00000328 <USI_TWI_Master_Transfer>:
USI_TWI_Master_Transfer():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:225
 Data to be sent has to be placed into the USIDR prior to calling
 this function. Data read, will be return'ed from the function.
---------------------------------------------------------------*/
unsigned char USI_TWI_Master_Transfer(unsigned char temp)
{
  USISR = temp;                                          // Set USISR according to temp.
 328:	8e b9       	out	0x0e, r24	; 14
_delay_loop_1():
c:\users\person\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:83
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 32a:	38 e2       	ldi	r19, 0x28	; 40
USI_TWI_Master_Transfer():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:233
         (1 << USIWM1) | (0 << USIWM0) |                 // Set USI in Two-wire mode.
         (1 << USICS1) | (0 << USICS0) | (1 << USICLK) | // Software clock strobe as source.
         (1 << USITC);                                   // Toggle Clock Port.
  do {
    if (USI_TWI_MASTER_SPEED) DELAY_T2TWI_FM; else DELAY_T2TWI;
    USICR = temp; // Generate positive SCL edge.
 32c:	8b e2       	ldi	r24, 0x2B	; 43
_delay_loop_1():
c:\users\person\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:83
 32e:	20 e2       	ldi	r18, 0x20	; 32
 330:	93 2f       	mov	r25, r19
 332:	9a 95       	dec	r25
 334:	f1 f7       	brne	.-4      	; 0x332 <USI_TWI_Master_Transfer+0xa>
USI_TWI_Master_Transfer():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:233
 336:	8d b9       	out	0x0d, r24	; 13
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:234
    while (!(PIN_USI_CL & (1 << PIN_USI_SCL)))
 338:	cc 9b       	sbis	0x19, 4	; 25
 33a:	fe cf       	rjmp	.-4      	; 0x338 <USI_TWI_Master_Transfer+0x10>
_delay_loop_1():
c:\users\person\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:83
 33c:	92 2f       	mov	r25, r18
 33e:	9a 95       	dec	r25
 340:	f1 f7       	brne	.-4      	; 0x33e <USI_TWI_Master_Transfer+0x16>
USI_TWI_Master_Transfer():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:237
      ; // Wait for SCL to go high.
    if (USI_TWI_MASTER_SPEED) DELAY_T4TWI_FM; else DELAY_T4TWI;
    USICR = temp;                   // Generate negative SCL edge.
 342:	8d b9       	out	0x0d, r24	; 13
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:238
  } while (!(USISR & (1 << USIOIF))); // Check for transfer complete.
 344:	76 9b       	sbis	0x0e, 6	; 14
 346:	f4 cf       	rjmp	.-24     	; 0x330 <USI_TWI_Master_Transfer+0x8>
_delay_loop_1():
c:\users\person\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:83
 348:	88 e2       	ldi	r24, 0x28	; 40
 34a:	8a 95       	dec	r24
 34c:	f1 f7       	brne	.-4      	; 0x34a <USI_TWI_Master_Transfer+0x22>
USI_TWI_Master_Transfer():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:241

  if (USI_TWI_MASTER_SPEED) DELAY_T2TWI_FM; else DELAY_T2TWI;
  temp  = USIDR;                 // Read out data.
 34e:	8f b1       	in	r24, 0x0f	; 15
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:242
  USIDR = 0xFF;                  // Release SDA.
 350:	9f ef       	ldi	r25, 0xFF	; 255
 352:	9f b9       	out	0x0f, r25	; 15
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:243
  DDR_USI |= (1 << PIN_USI_SDA); // Enable SDA as output.
 354:	d6 9a       	sbi	0x1a, 6	; 26
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:246

  return temp; // Return the data from the USIDR
}
 356:	08 95       	ret

00000358 <USI_TWI_Start_Transceiver_With_Data_Stop>:
USI_TWI_Start_Transceiver_With_Data_Stop():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:108
 parameter that defines if a Stop Condition should be send at the end
 of the transmission.
---------------------------------------------------------------*/

unsigned char USI_TWI_Start_Transceiver_With_Data_Stop(unsigned char *msg, unsigned char msgSize, unsigned char stop)
{
 358:	ff 92       	push	r15
 35a:	0f 93       	push	r16
 35c:	1f 93       	push	r17
 35e:	cf 93       	push	r28
 360:	df 93       	push	r29
 362:	06 2f       	mov	r16, r22
 364:	14 2f       	mov	r17, r20
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:116

  unsigned char tempUSISR_1bit = (1 << USISIF) | (1 << USIOIF) | (1 << USIPF) | (1 << USIDC) | (0xE << USICNT0);
  // Prepare register value to: Clear flags, and set USI to shift 1 bit i.e. count 2 clock edges.

  USI_TWI_state.errorState  = 0;
  USI_TWI_state.addressMode = TRUE;
 366:	21 e0       	ldi	r18, 0x01	; 1
 368:	20 93 89 00 	sts	0x0089, r18	; 0x800089 <USI_TWI_state>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:146
    USI_TWI_state.errorState = USI_TWI_UE_DATA_COL;
    return (FALSE);
  }
#endif

  if (!(*msg & (1 << TWI_READ_BIT))) // The LSB in the address byte determines if is a masterRead or masterWrite operation.
 36c:	fc 01       	movw	r30, r24
 36e:	20 81       	ld	r18, Z
 370:	20 fd       	sbrc	r18, 0
 372:	03 c0       	rjmp	.+6      	; 0x37a <USI_TWI_Start_Transceiver_With_Data_Stop+0x22>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:148
  {
    USI_TWI_state.masterWriteDataMode = TRUE;
 374:	23 e0       	ldi	r18, 0x03	; 3
 376:	20 93 89 00 	sts	0x0089, r18	; 0x800089 <USI_TWI_state>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:152
  }

  /* Release SCL to ensure that (repeated) Start can be performed */
  PORT_USI_CL |= (1 << PIN_USI_SCL); // Release SCL.
 37a:	dc 9a       	sbi	0x1b, 4	; 27
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:153
  while (!(PIN_USI_CL & (1 << PIN_USI_SCL)))
 37c:	cc 9b       	sbis	0x19, 4	; 25
 37e:	fe cf       	rjmp	.-4      	; 0x37c <USI_TWI_Start_Transceiver_With_Data_Stop+0x24>
_delay_loop_1():
c:\users\person\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:83
 380:	28 e2       	ldi	r18, 0x28	; 40
 382:	2a 95       	dec	r18
 384:	f1 f7       	brne	.-4      	; 0x382 <USI_TWI_Start_Transceiver_With_Data_Stop+0x2a>
USI_TWI_Start_Transceiver_With_Data_Stop():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:159
    ; // Verify that SCL becomes high.
  if (USI_TWI_MASTER_SPEED) DELAY_T4TWI_FM; // Delay for T4TWI if TWI_FAST_MODE
  else DELAY_T2TWI;    // Delay for T2TWI if TWI_STANDARD_MODE

  /* Generate Start Condition */
  PORT_USI &= ~(1 << PIN_USI_SDA); // Force SDA LOW.
 386:	de 98       	cbi	0x1b, 6	; 27
_delay_loop_1():
c:\users\person\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:83
 388:	20 e2       	ldi	r18, 0x20	; 32
 38a:	2a 95       	dec	r18
 38c:	f1 f7       	brne	.-4      	; 0x38a <USI_TWI_Start_Transceiver_With_Data_Stop+0x32>
USI_TWI_Start_Transceiver_With_Data_Stop():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:163

  if (USI_TWI_MASTER_SPEED) DELAY_T4TWI_FM; else DELAY_T4TWI; // UGGGGLLLYYYYY - but if you never call clock() which is the only thing that could change USI_TWI_MASTER_SPEED, should be optimized out

  PORT_USI_CL &= ~(1 << PIN_USI_SCL); // Pull SCL LOW.
 38e:	dc 98       	cbi	0x1b, 4	; 27
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:164
  PORT_USI |= (1 << PIN_USI_SDA);  // Release SDA.
 390:	de 9a       	sbi	0x1b, 6	; 27
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:167

#ifdef SIGNAL_VERIFY
  if (!(USISR & (1 << USISIF))) {
 392:	77 99       	sbic	0x0e, 7	; 14
 394:	0b c0       	rjmp	.+22     	; 0x3ac <USI_TWI_Start_Transceiver_With_Data_Stop+0x54>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:168
    USI_TWI_state.errorState = USI_TWI_MISSING_START_CON;
 396:	87 e0       	ldi	r24, 0x07	; 7
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:186

      /* Clock and verify (N)ACK from slave */
      DDR_USI &= ~(1 << PIN_USI_SDA); // Enable SDA as input.
      if (USI_TWI_Master_Transfer(tempUSISR_1bit) & (1 << TWI_NACK_BIT)) {
        if (USI_TWI_state.addressMode)
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_ADDRESS;
 398:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <USI_TWI_state>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:189
        else
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_DATA;
        return (FALSE);
 39c:	10 e0       	ldi	r17, 0x00	; 0
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:216
    USI_TWI_Master_Stop(); // Send a STOP condition on the TWI bus.
  }

  /* Transmission successfully completed*/
  return (TRUE);
}
 39e:	81 2f       	mov	r24, r17
 3a0:	df 91       	pop	r29
 3a2:	cf 91       	pop	r28
 3a4:	1f 91       	pop	r17
 3a6:	0f 91       	pop	r16
 3a8:	ff 90       	pop	r15
 3aa:	08 95       	ret
 3ac:	ec 01       	movw	r28, r24
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:202
      *(msg++) = USI_TWI_Master_Transfer(tempUSISR_8bit);

      /* Prepare to generate ACK (or NACK in case of End Of Transmission) */
      if (msgSize == 1) // If transmission of last byte was performed.
      {
        USIDR = 0xFF; // Load NACK to confirm End Of Transmission.
 3ae:	ff 24       	eor	r15, r15
 3b0:	fa 94       	dec	r15
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:176
#endif

  /*Write address and Read/Write data */
  do {
    /* If masterWrite cycle (or initial address transmission)*/
    if (USI_TWI_state.addressMode || USI_TWI_state.masterWriteDataMode) {
 3b2:	80 91 89 00 	lds	r24, 0x0089	; 0x800089 <USI_TWI_state>
 3b6:	83 70       	andi	r24, 0x03	; 3
 3b8:	19 f1       	breq	.+70     	; 0x400 <__LOCK_REGION_LENGTH__>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:178
      /* Write a byte */
      PORT_USI_CL &= ~(1 << PIN_USI_SCL);         // Pull SCL LOW.
 3ba:	dc 98       	cbi	0x1b, 4	; 27
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:179
      USIDR = *(msg++);                        // Setup data.
 3bc:	88 81       	ld	r24, Y
 3be:	8f b9       	out	0x0f, r24	; 15
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:180
      USI_TWI_Master_Transfer(tempUSISR_8bit); // Send 8 bits on bus.
 3c0:	80 ef       	ldi	r24, 0xF0	; 240
 3c2:	b2 df       	rcall	.-156    	; 0x328 <USI_TWI_Master_Transfer>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:183

      /* Clock and verify (N)ACK from slave */
      DDR_USI &= ~(1 << PIN_USI_SDA); // Enable SDA as input.
 3c4:	d6 98       	cbi	0x1a, 6	; 26
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:184
      if (USI_TWI_Master_Transfer(tempUSISR_1bit) & (1 << TWI_NACK_BIT)) {
 3c6:	8e ef       	ldi	r24, 0xFE	; 254
 3c8:	af df       	rcall	.-162    	; 0x328 <USI_TWI_Master_Transfer>
 3ca:	80 ff       	sbrs	r24, 0
 3cc:	0c c0       	rjmp	.+24     	; 0x3e6 <USI_TWI_Start_Transceiver_With_Data_Stop+0x8e>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:185
        if (USI_TWI_state.addressMode)
 3ce:	80 91 89 00 	lds	r24, 0x0089	; 0x800089 <USI_TWI_state>
 3d2:	18 2f       	mov	r17, r24
 3d4:	11 70       	andi	r17, 0x01	; 1
 3d6:	80 ff       	sbrs	r24, 0
 3d8:	02 c0       	rjmp	.+4      	; 0x3de <USI_TWI_Start_Transceiver_With_Data_Stop+0x86>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:186
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_ADDRESS;
 3da:	86 e0       	ldi	r24, 0x06	; 6
 3dc:	dd cf       	rjmp	.-70     	; 0x398 <USI_TWI_Start_Transceiver_With_Data_Stop+0x40>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:188
        else
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_DATA;
 3de:	85 e0       	ldi	r24, 0x05	; 5
USI_TWI_Master_Stop():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:264
  PORT_USI |= (1 << PIN_USI_SDA); // Release SDA.
  if (USI_TWI_MASTER_SPEED) DELAY_T2TWI_FM; else DELAY_T2TWI;

#ifdef SIGNAL_VERIFY
  if (!(USISR & (1 << USIPF))) {
    USI_TWI_state.errorState = USI_TWI_MISSING_STOP_CON;
 3e0:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <USI_TWI_state>
 3e4:	dc cf       	rjmp	.-72     	; 0x39e <USI_TWI_Start_Transceiver_With_Data_Stop+0x46>
USI_TWI_Start_Transceiver_With_Data_Stop():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:191
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_ADDRESS;
        else
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_DATA;
        return (FALSE);
      }
      USI_TWI_state.addressMode = FALSE; // Only perform address transmission once.
 3e6:	80 91 89 00 	lds	r24, 0x0089	; 0x800089 <USI_TWI_state>
 3ea:	8e 7f       	andi	r24, 0xFE	; 254
 3ec:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <USI_TWI_state>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:208
      } else {
        USIDR = 0x00; // Load ACK. Set data register bit 7 (output for SDA) low.
      }
      USI_TWI_Master_Transfer(tempUSISR_1bit); // Generate ACK/NACK.
    }
  } while (--msgSize); // Until all data sent/received.
 3f0:	01 50       	subi	r16, 0x01	; 1
 3f2:	21 96       	adiw	r28, 0x01	; 1
 3f4:	01 11       	cpse	r16, r1
 3f6:	dd cf       	rjmp	.-70     	; 0x3b2 <USI_TWI_Start_Transceiver_With_Data_Stop+0x5a>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:210

  if (stop) {
 3f8:	11 11       	cpse	r17, r1
 3fa:	0e c0       	rjmp	.+28     	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:215
    USI_TWI_Master_Stop(); // Send a STOP condition on the TWI bus.
  }

  /* Transmission successfully completed*/
  return (TRUE);
 3fc:	11 e0       	ldi	r17, 0x01	; 1
 3fe:	cf cf       	rjmp	.-98     	; 0x39e <USI_TWI_Start_Transceiver_With_Data_Stop+0x46>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:196
      USI_TWI_state.addressMode = FALSE; // Only perform address transmission once.
    }
    /* Else masterRead cycle*/
    else {
      /* Read a data byte */
      DDR_USI &= ~(1 << PIN_USI_SDA); // Enable SDA as input.
 400:	d6 98       	cbi	0x1a, 6	; 26
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:197
      *(msg++) = USI_TWI_Master_Transfer(tempUSISR_8bit);
 402:	80 ef       	ldi	r24, 0xF0	; 240
 404:	91 df       	rcall	.-222    	; 0x328 <USI_TWI_Master_Transfer>
 406:	88 83       	st	Y, r24
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:200

      /* Prepare to generate ACK (or NACK in case of End Of Transmission) */
      if (msgSize == 1) // If transmission of last byte was performed.
 408:	01 30       	cpi	r16, 0x01	; 1
 40a:	21 f4       	brne	.+8      	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:202
      {
        USIDR = 0xFF; // Load NACK to confirm End Of Transmission.
 40c:	ff b8       	out	0x0f, r15	; 15
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:206
      } else {
        USIDR = 0x00; // Load ACK. Set data register bit 7 (output for SDA) low.
      }
      USI_TWI_Master_Transfer(tempUSISR_1bit); // Generate ACK/NACK.
 40e:	8e ef       	ldi	r24, 0xFE	; 254
 410:	8b df       	rcall	.-234    	; 0x328 <USI_TWI_Master_Transfer>
 412:	ee cf       	rjmp	.-36     	; 0x3f0 <USI_TWI_Start_Transceiver_With_Data_Stop+0x98>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:204
      /* Prepare to generate ACK (or NACK in case of End Of Transmission) */
      if (msgSize == 1) // If transmission of last byte was performed.
      {
        USIDR = 0xFF; // Load NACK to confirm End Of Transmission.
      } else {
        USIDR = 0x00; // Load ACK. Set data register bit 7 (output for SDA) low.
 414:	1f b8       	out	0x0f, r1	; 15
 416:	fb cf       	rjmp	.-10     	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
USI_TWI_Master_Stop():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:254
 Function for generating a TWI Stop Condition. Used to release
 the TWI bus.
---------------------------------------------------------------*/
unsigned char USI_TWI_Master_Stop(void)
{
  PORT_USI &= ~(1 << PIN_USI_SDA); // Pull SDA low.
 418:	de 98       	cbi	0x1b, 6	; 27
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:255
  PORT_USI_CL |= (1 << PIN_USI_SCL);  // Release SCL.
 41a:	dc 9a       	sbi	0x1b, 4	; 27
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:256
  while (!(PIN_USI_CL & (1 << PIN_USI_SCL)))
 41c:	cc 9b       	sbis	0x19, 4	; 25
 41e:	fe cf       	rjmp	.-4      	; 0x41c <__LOCK_REGION_LENGTH__+0x1c>
_delay_loop_1():
c:\users\person\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:83
 420:	80 e2       	ldi	r24, 0x20	; 32
 422:	8a 95       	dec	r24
 424:	f1 f7       	brne	.-4      	; 0x422 <__LOCK_REGION_LENGTH__+0x22>
USI_TWI_Master_Stop():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:259
    ; // Wait for SCL to go high.
  if (USI_TWI_MASTER_SPEED) DELAY_T4TWI_FM; else DELAY_T4TWI;
  PORT_USI |= (1 << PIN_USI_SDA); // Release SDA.
 426:	de 9a       	sbi	0x1b, 6	; 27
_delay_loop_1():
c:\users\person\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:83
 428:	88 e2       	ldi	r24, 0x28	; 40
 42a:	8a 95       	dec	r24
 42c:	f1 f7       	brne	.-4      	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
USI_TWI_Master_Stop():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:263
  if (USI_TWI_MASTER_SPEED) DELAY_T2TWI_FM; else DELAY_T2TWI;

#ifdef SIGNAL_VERIFY
  if (!(USISR & (1 << USIPF))) {
 42e:	75 99       	sbic	0x0e, 5	; 14
 430:	e5 cf       	rjmp	.-54     	; 0x3fc <USI_TWI_Start_Transceiver_With_Data_Stop+0xa4>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:264
    USI_TWI_state.errorState = USI_TWI_MISSING_STOP_CON;
 432:	88 e0       	ldi	r24, 0x08	; 8
 434:	d5 cf       	rjmp	.-86     	; 0x3e0 <USI_TWI_Start_Transceiver_With_Data_Stop+0x88>

00000436 <TwoWire::endTransmission() [clone .constprop.9]>:
_ZN7TwoWire15endTransmissionEv.constprop.9():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:478

uint8_t TwoWire::endTransmission(uint8_t sendStop) {
  // transmit buffer (blocking)
  uint8_t ret = USI_TWI_Start_Transceiver_With_Data_Stop(Buffer,
                                                         BufferLength,
                                                         sendStop);
 436:	41 e0       	ldi	r20, 0x01	; 1
 438:	60 91 8c 00 	lds	r22, 0x008C	; 0x80008c <TwoWire::BufferLength>
 43c:	80 e6       	ldi	r24, 0x60	; 96
 43e:	90 e0       	ldi	r25, 0x00	; 0
 440:	8b df       	rcall	.-234    	; 0x358 <USI_TWI_Start_Transceiver_With_Data_Stop>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:480
  // reset tx buffer iterator vars
  BufferIndex = 0;
 442:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <TwoWire::BufferIndex>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:481
  BufferLength = 0;
 446:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <TwoWire::BufferLength>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:483
  // indicate that we are done transmitting
  transmitting = 0;
 44a:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <TwoWire::transmitting>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:485
  // check for error
  if (ret == FALSE) {
 44e:	81 11       	cpse	r24, r1
 450:	10 c0       	rjmp	.+32     	; 0x472 <TwoWire::endTransmission() [clone .constprop.9]+0x3c>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:486
    switch (USI_TWI_Get_State_Info()) {
 452:	80 91 89 00 	lds	r24, 0x0089	; 0x800089 <USI_TWI_state>
 456:	85 30       	cpi	r24, 0x05	; 5
 458:	41 f0       	breq	.+16     	; 0x46a <TwoWire::endTransmission() [clone .constprop.9]+0x34>
 45a:	86 30       	cpi	r24, 0x06	; 6
 45c:	21 f0       	breq	.+8      	; 0x466 <TwoWire::endTransmission() [clone .constprop.9]+0x30>
 45e:	81 30       	cpi	r24, 0x01	; 1
 460:	31 f4       	brne	.+12     	; 0x46e <TwoWire::endTransmission() [clone .constprop.9]+0x38>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:488
    case USI_TWI_DATA_OUT_OF_BOUND:
      return 1; //data too long to fit in transmit buffer
 462:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:501
  return 0; //success
}

uint8_t TwoWire::endTransmission(void) {
  return endTransmission(true);
}
 464:	08 95       	ret
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:490
  if (ret == FALSE) {
    switch (USI_TWI_Get_State_Info()) {
    case USI_TWI_DATA_OUT_OF_BOUND:
      return 1; //data too long to fit in transmit buffer
    case USI_TWI_NO_ACK_ON_ADDRESS:
      return 2; //received NACK on transmit of address
 466:	82 e0       	ldi	r24, 0x02	; 2
 468:	08 95       	ret
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:492
    case USI_TWI_NO_ACK_ON_DATA:
      return 3; //received NACK on transmit of data
 46a:	83 e0       	ldi	r24, 0x03	; 3
 46c:	08 95       	ret
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:494
    }
    return 4; //other error
 46e:	84 e0       	ldi	r24, 0x04	; 4
 470:	08 95       	ret
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:496
  }
  return 0; //success
 472:	80 e0       	ldi	r24, 0x00	; 0
 474:	08 95       	ret

00000476 <Single(unsigned char)>:
_Z6Singleh():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:145
// Current plot position
int x0;
int y0;

// Write a single command
void Single(uint8_t x) {
 476:	cf 93       	push	r28
 478:	c8 2f       	mov	r28, r24
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:146
  Wire.write(onecommand);
 47a:	80 e8       	ldi	r24, 0x80	; 128
 47c:	90 e0       	ldi	r25, 0x00	; 0
 47e:	48 df       	rcall	.-368    	; 0x310 <TwoWire::write(int) [clone .constprop.7]>
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:147
  Wire.write(x);
 480:	8c 2f       	mov	r24, r28
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:148
}
 482:	cf 91       	pop	r28
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:147
int y0;

// Write a single command
void Single(uint8_t x) {
  Wire.write(onecommand);
  Wire.write(x);
 484:	12 cf       	rjmp	.-476    	; 0x2aa <TwoWire::write(unsigned char) [clone .constprop.8]>

00000486 <PlotText(char const*)>:
_Z8PlotTextPKc():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:261
  }
  Wire.endTransmission();
}

// Plot text starting at the current plot position
void PlotText(PGM_P s) {
 486:	9f 92       	push	r9
 488:	af 92       	push	r10
 48a:	bf 92       	push	r11
 48c:	cf 92       	push	r12
 48e:	df 92       	push	r13
 490:	ef 92       	push	r14
 492:	ff 92       	push	r15
 494:	0f 93       	push	r16
 496:	1f 93       	push	r17
 498:	cf 93       	push	r28
 49a:	df 93       	push	r29
 49c:	6c 01       	movw	r12, r24
requestFrom():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:426
  // clamp to buffer length
  if (quantity > TWI_BUFFER_SIZE) {
    quantity = TWI_BUFFER_SIZE;
  }
  // set address of targeted slave and read mode
  Buffer[0] = (address << TWI_ADR_BITS) | (1 << TWI_READ_BIT);
 49e:	e9 e7       	ldi	r30, 0x79	; 121
 4a0:	9e 2e       	mov	r9, r30
_Z8PlotTextPKc():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:264
  int p = (int) s;
  while (1) {
    char c = pgm_read_byte(p++);
 4a2:	f6 01       	movw	r30, r12
 4a4:	14 91       	lpm	r17, Z
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:265
    if (c == 0) return;
 4a6:	11 23       	and	r17, r17
 4a8:	09 f4       	brne	.+2      	; 0x4ac <PlotText(char const*)+0x26>
 4aa:	7d c0       	rjmp	.+250    	; 0x5a6 <PlotText(char const*)+0x120>
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:266
    PlotChar(c, x0, y0 >> 3);
 4ac:	e0 90 83 00 	lds	r14, 0x0083	; 0x800083 <y0>
 4b0:	f0 90 84 00 	lds	r15, 0x0084	; 0x800084 <y0+0x1>
 4b4:	73 e0       	ldi	r23, 0x03	; 3
 4b6:	f5 94       	asr	r15
 4b8:	e7 94       	ror	r14
 4ba:	7a 95       	dec	r23
 4bc:	e1 f7       	brne	.-8      	; 0x4b6 <PlotText(char const*)+0x30>
 4be:	c0 91 85 00 	lds	r28, 0x0085	; 0x800085 <x0>
 4c2:	d0 91 86 00 	lds	r29, 0x0086	; 0x800086 <x0+0x1>
beginTransmission():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:471
  BufferIndex = 1; // reserved by slave address
  BufferLength = BufferIndex;
}

void TwoWire::beginTransmission(int address) {
  beginTransmission((uint8_t)address);
 4c6:	8c e3       	ldi	r24, 0x3C	; 60
 4c8:	24 df       	rcall	.-440    	; 0x312 <TwoWire::beginTransmission(unsigned char) [clone .constprop.6]>
PlotChar():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:243

// Plot an ASCII character with bottom left corner at x,y
// only supports y divisible by 8, hence page instead of y
void PlotChar(int c, int x, int page) {
  Wire.beginTransmission(address);
  Single(0xB0 + page); 
 4ca:	80 eb       	ldi	r24, 0xB0	; 176
 4cc:	8e 0d       	add	r24, r14
 4ce:	d3 df       	rcall	.-90     	; 0x476 <Single(unsigned char)>
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:253
    Wire.write(onedata);
    Wire.endTransmission();
    Wire.requestFrom(address, 2);
    Wire.beginTransmission(address);
    Wire.write(onedata);
    int bits = ReverseByte(pgm_read_byte(&CharMap[c - 32][col]));
 4d0:	81 2f       	mov	r24, r17
 4d2:	11 0f       	add	r17, r17
 4d4:	99 0b       	sbc	r25, r25
 4d6:	80 97       	sbiw	r24, 0x20	; 32
 4d8:	66 e0       	ldi	r22, 0x06	; 6
 4da:	70 e0       	ldi	r23, 0x00	; 0
 4dc:	9a d1       	rcall	.+820    	; 0x812 <__mulhi3>
 4de:	7e 01       	movw	r14, r28
 4e0:	f2 e0       	ldi	r31, 0x02	; 2
 4e2:	ef 0e       	add	r14, r31
 4e4:	f1 1c       	adc	r15, r1
_Z8PlotTextPKc():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:244
// Plot an ASCII character with bottom left corner at x,y
// only supports y divisible by 8, hence page instead of y
void PlotChar(int c, int x, int page) {
  Wire.beginTransmission(address);
  Single(0xB0 + page); 
  for (int col = 0; col < 6; col++) {
 4e6:	10 e0       	ldi	r17, 0x00	; 0
 4e8:	00 e0       	ldi	r16, 0x00	; 0
PlotChar():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:253
    Wire.write(onedata);
    Wire.endTransmission();
    Wire.requestFrom(address, 2);
    Wire.beginTransmission(address);
    Wire.write(onedata);
    int bits = ReverseByte(pgm_read_byte(&CharMap[c - 32][col]));
 4ea:	8e 5d       	subi	r24, 0xDE	; 222
 4ec:	9f 4f       	sbci	r25, 0xFF	; 255
 4ee:	5c 01       	movw	r10, r24
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:245
// only supports y divisible by 8, hence page instead of y
void PlotChar(int c, int x, int page) {
  Wire.beginTransmission(address);
  Single(0xB0 + page); 
  for (int col = 0; col < 6; col++) {
    Single(0x00 + ((x + 2 + col) & 0x0F));  // Column low nibble
 4f0:	8e 2d       	mov	r24, r14
 4f2:	8f 70       	andi	r24, 0x0F	; 15
 4f4:	c0 df       	rcall	.-128    	; 0x476 <Single(unsigned char)>
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:246
    Single(0x10 + ((x + 2 + col) >> 4));    // Column high nibble
 4f6:	c7 01       	movw	r24, r14
 4f8:	64 e0       	ldi	r22, 0x04	; 4
 4fa:	95 95       	asr	r25
 4fc:	87 95       	ror	r24
 4fe:	6a 95       	dec	r22
 500:	e1 f7       	brne	.-8      	; 0x4fa <PlotText(char const*)+0x74>
 502:	80 5f       	subi	r24, 0xF0	; 240
 504:	b8 df       	rcall	.-144    	; 0x476 <Single(unsigned char)>
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:247
    Single(0xE0);                           // Read modify write
 506:	80 ee       	ldi	r24, 0xE0	; 224
 508:	b6 df       	rcall	.-148    	; 0x476 <Single(unsigned char)>
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:248
    Wire.write(onedata);
 50a:	80 ec       	ldi	r24, 0xC0	; 192
 50c:	90 e0       	ldi	r25, 0x00	; 0
 50e:	00 df       	rcall	.-512    	; 0x310 <TwoWire::write(int) [clone .constprop.7]>
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:249
    Wire.endTransmission();
 510:	92 df       	rcall	.-220    	; 0x436 <TwoWire::endTransmission() [clone .constprop.9]>
requestFrom():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:426
  // clamp to buffer length
  if (quantity > TWI_BUFFER_SIZE) {
    quantity = TWI_BUFFER_SIZE;
  }
  // set address of targeted slave and read mode
  Buffer[0] = (address << TWI_ADR_BITS) | (1 << TWI_READ_BIT);
 512:	90 92 60 00 	sts	0x0060, r9	; 0x800060 <__DATA_REGION_ORIGIN__>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:429
  // perform blocking read into buffer
  uint8_t ret = USI_TWI_Start_Transceiver_With_Data_Stop(Buffer, quantity,
                                                         sendStop);
 516:	41 e0       	ldi	r20, 0x01	; 1
 518:	63 e0       	ldi	r22, 0x03	; 3
 51a:	80 e6       	ldi	r24, 0x60	; 96
 51c:	90 e0       	ldi	r25, 0x00	; 0
 51e:	1c df       	rcall	.-456    	; 0x358 <USI_TWI_Start_Transceiver_With_Data_Stop>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:431
  // set rx buffer iterator vars
  BufferIndex = 1; // ignore slave address
 520:	91 e0       	ldi	r25, 0x01	; 1
 522:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <TwoWire::BufferIndex>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:433
  // check for error
  if (ret == FALSE) {
 526:	81 11       	cpse	r24, r1
 528:	3a c0       	rjmp	.+116    	; 0x59e <PlotText(char const*)+0x118>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:434
    BufferLength = BufferIndex;
 52a:	90 93 8c 00 	sts	0x008C, r25	; 0x80008c <TwoWire::BufferLength>
beginTransmission():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:471
  BufferIndex = 1; // reserved by slave address
  BufferLength = BufferIndex;
}

void TwoWire::beginTransmission(int address) {
  beginTransmission((uint8_t)address);
 52e:	8c e3       	ldi	r24, 0x3C	; 60
 530:	f0 de       	rcall	.-544    	; 0x312 <TwoWire::beginTransmission(unsigned char) [clone .constprop.6]>
PlotChar():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:252
    Wire.requestFrom(address, 2);
    Wire.beginTransmission(address);
    Wire.write(onedata);
 532:	80 ec       	ldi	r24, 0xC0	; 192
 534:	90 e0       	ldi	r25, 0x00	; 0
 536:	ec de       	rcall	.-552    	; 0x310 <TwoWire::write(int) [clone .constprop.7]>
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:253
    int bits = ReverseByte(pgm_read_byte(&CharMap[c - 32][col]));
 538:	f5 01       	movw	r30, r10
 53a:	e0 0f       	add	r30, r16
 53c:	f1 1f       	adc	r31, r17
 53e:	e4 91       	lpm	r30, Z
ReverseByte():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:233
    }
  }
}

uint8_t ReverseByte(uint8_t x) {
  x = ((x >> 1) & 0x55) | ((x << 1) & 0xaa);
 540:	f0 e0       	ldi	r31, 0x00	; 0
 542:	9f 01       	movw	r18, r30
 544:	35 95       	asr	r19
 546:	27 95       	ror	r18
 548:	25 75       	andi	r18, 0x55	; 85
 54a:	ee 0f       	add	r30, r30
 54c:	ff 1f       	adc	r31, r31
 54e:	ea 7a       	andi	r30, 0xAA	; 170
 550:	2e 2b       	or	r18, r30
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:234
  x = ((x >> 2) & 0x33) | ((x << 2) & 0xcc);
 552:	30 e0       	ldi	r19, 0x00	; 0
 554:	c9 01       	movw	r24, r18
 556:	95 95       	asr	r25
 558:	87 95       	ror	r24
 55a:	95 95       	asr	r25
 55c:	87 95       	ror	r24
 55e:	83 73       	andi	r24, 0x33	; 51
 560:	22 0f       	add	r18, r18
 562:	33 1f       	adc	r19, r19
 564:	22 0f       	add	r18, r18
 566:	33 1f       	adc	r19, r19
 568:	2c 7c       	andi	r18, 0xCC	; 204
 56a:	28 2b       	or	r18, r24
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:235
  x = ((x >> 4) & 0x0f) | ((x << 4) & 0xf0);
 56c:	22 95       	swap	r18
PlotChar():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:254
    Wire.endTransmission();
    Wire.requestFrom(address, 2);
    Wire.beginTransmission(address);
    Wire.write(onedata);
    int bits = ReverseByte(pgm_read_byte(&CharMap[c - 32][col]));
    Wire.write(bits);
 56e:	82 2f       	mov	r24, r18
 570:	90 e0       	ldi	r25, 0x00	; 0
 572:	ce de       	rcall	.-612    	; 0x310 <TwoWire::write(int) [clone .constprop.7]>
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:255
    Single(0xEE);  // Cancel read modify write
 574:	8e ee       	ldi	r24, 0xEE	; 238
 576:	7f df       	rcall	.-258    	; 0x476 <Single(unsigned char)>
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:244
// Plot an ASCII character with bottom left corner at x,y
// only supports y divisible by 8, hence page instead of y
void PlotChar(int c, int x, int page) {
  Wire.beginTransmission(address);
  Single(0xB0 + page); 
  for (int col = 0; col < 6; col++) {
 578:	0f 5f       	subi	r16, 0xFF	; 255
 57a:	1f 4f       	sbci	r17, 0xFF	; 255
 57c:	2f ef       	ldi	r18, 0xFF	; 255
 57e:	e2 1a       	sub	r14, r18
 580:	f2 0a       	sbc	r15, r18
 582:	06 30       	cpi	r16, 0x06	; 6
 584:	11 05       	cpc	r17, r1
 586:	09 f0       	breq	.+2      	; 0x58a <PlotText(char const*)+0x104>
 588:	b3 cf       	rjmp	.-154    	; 0x4f0 <PlotText(char const*)+0x6a>
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:257
    Wire.write(onedata);
    int bits = ReverseByte(pgm_read_byte(&CharMap[c - 32][col]));
    Wire.write(bits);
    Single(0xEE);  // Cancel read modify write
  }
  Wire.endTransmission();
 58a:	55 df       	rcall	.-342    	; 0x436 <TwoWire::endTransmission() [clone .constprop.9]>
_Z8PlotTextPKc():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:267
  int p = (int) s;
  while (1) {
    char c = pgm_read_byte(p++);
    if (c == 0) return;
    PlotChar(c, x0, y0 >> 3);
    x0 = x0 + 6;
 58c:	26 96       	adiw	r28, 0x06	; 6
 58e:	d0 93 86 00 	sts	0x0086, r29	; 0x800086 <x0+0x1>
 592:	c0 93 85 00 	sts	0x0085, r28	; 0x800085 <x0>
 596:	8f ef       	ldi	r24, 0xFF	; 255
 598:	c8 1a       	sub	r12, r24
 59a:	d8 0a       	sbc	r13, r24
 59c:	82 cf       	rjmp	.-252    	; 0x4a2 <PlotText(char const*)+0x1c>
requestFrom():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:437
  // check for error
  if (ret == FALSE) {
    BufferLength = BufferIndex;
    return 0;
  }
  BufferLength = quantity;
 59e:	83 e0       	ldi	r24, 0x03	; 3
 5a0:	80 93 8c 00 	sts	0x008C, r24	; 0x80008c <TwoWire::BufferLength>
 5a4:	c4 cf       	rjmp	.-120    	; 0x52e <PlotText(char const*)+0xa8>
_Z8PlotTextPKc():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:269
  }
}
 5a6:	df 91       	pop	r29
 5a8:	cf 91       	pop	r28
 5aa:	1f 91       	pop	r17
 5ac:	0f 91       	pop	r16
 5ae:	ff 90       	pop	r15
 5b0:	ef 90       	pop	r14
 5b2:	df 90       	pop	r13
 5b4:	cf 90       	pop	r12
 5b6:	bf 90       	pop	r11
 5b8:	af 90       	pop	r10
 5ba:	9f 90       	pop	r9
 5bc:	08 95       	ret

000005be <__vector_16>:
__vector_16():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:207
/*----------------------------------------------------------
 Handles all the communication. Is disabled only when waiting
 for new Start Condition.
----------------------------------------------------------*/
ISR(USI_OVERFLOW_VECTOR)
{
 5be:	1f 92       	push	r1
 5c0:	0f 92       	push	r0
 5c2:	0f b6       	in	r0, 0x3f	; 63
 5c4:	0f 92       	push	r0
 5c6:	11 24       	eor	r1, r1
 5c8:	2f 93       	push	r18
 5ca:	8f 93       	push	r24
 5cc:	9f 93       	push	r25
 5ce:	ef 93       	push	r30
 5d0:	ff 93       	push	r31
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:212
  unsigned char tmpRxHead;
  unsigned char tmpTxTail; // Temporary variables to store volatiles
  unsigned char tmpUSIDR;

  switch (USI_TWI_Overflow_State) {
 5d2:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <USI_TWI_Overflow_State>
 5d6:	82 30       	cpi	r24, 0x02	; 2
 5d8:	09 f4       	brne	.+2      	; 0x5dc <__vector_16+0x1e>
 5da:	5e c0       	rjmp	.+188    	; 0x698 <__vector_16+0xda>
 5dc:	78 f4       	brcc	.+30     	; 0x5fc <__vector_16+0x3e>
 5de:	88 23       	and	r24, r24
 5e0:	49 f1       	breq	.+82     	; 0x634 <__vector_16+0x76>
 5e2:	81 30       	cpi	r24, 0x01	; 1
 5e4:	09 f4       	brne	.+2      	; 0x5e8 <__vector_16+0x2a>
 5e6:	3e c0       	rjmp	.+124    	; 0x664 <__vector_16+0xa6>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:306
    {
      SET_USI_TO_SEND_NACK();
    }
    break;
  }
}
 5e8:	ff 91       	pop	r31
 5ea:	ef 91       	pop	r30
 5ec:	9f 91       	pop	r25
 5ee:	8f 91       	pop	r24
 5f0:	2f 91       	pop	r18
 5f2:	0f 90       	pop	r0
 5f4:	0f be       	out	0x3f, r0	; 63
 5f6:	0f 90       	pop	r0
 5f8:	1f 90       	pop	r1
 5fa:	18 95       	reti
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:212
{
  unsigned char tmpRxHead;
  unsigned char tmpTxTail; // Temporary variables to store volatiles
  unsigned char tmpUSIDR;

  switch (USI_TWI_Overflow_State) {
 5fc:	84 30       	cpi	r24, 0x04	; 4
 5fe:	09 f4       	brne	.+2      	; 0x602 <__vector_16+0x44>
 600:	51 c0       	rjmp	.+162    	; 0x6a4 <__vector_16+0xe6>
 602:	48 f1       	brcs	.+82     	; 0x656 <__vector_16+0x98>
 604:	85 30       	cpi	r24, 0x05	; 5
 606:	81 f7       	brne	.-32     	; 0x5e8 <__vector_16+0x2a>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:293
    break;

  // Copy data from USIDR and send ACK. Next USI_SLAVE_REQUEST_DATA
  case USI_SLAVE_GET_DATA_AND_SEND_ACK:
    // Put data into Buffer
    USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 608:	84 e0       	ldi	r24, 0x04	; 4
 60a:	80 93 82 00 	sts	0x0082, r24	; 0x800082 <USI_TWI_Overflow_State>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:294
    tmpUSIDR              = USIDR; // Not necessary, but prevents warnings
 60e:	9f b1       	in	r25, 0x0f	; 15
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:295
    tmpRxHead = (TWI_RxHead + 1) & TWI_RX_BUFFER_MASK;
 610:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <TWI_RxHead>
 614:	8f 5f       	subi	r24, 0xFF	; 255
 616:	8f 70       	andi	r24, 0x0F	; 15
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:296
    if (TWI_RxTail != tmpRxHead) {
 618:	20 91 80 00 	lds	r18, 0x0080	; 0x800080 <TWI_RxTail>
 61c:	28 17       	cp	r18, r24
 61e:	09 f4       	brne	.+2      	; 0x622 <__vector_16+0x64>
 620:	46 c0       	rjmp	.+140    	; 0x6ae <__vector_16+0xf0>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:297
      TWI_RxHead            = tmpRxHead;
 622:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <TWI_RxHead>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:298
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
 626:	e0 91 81 00 	lds	r30, 0x0081	; 0x800081 <TWI_RxHead>
 62a:	f0 e0       	ldi	r31, 0x00	; 0
 62c:	e0 5a       	subi	r30, 0xA0	; 160
 62e:	ff 4f       	sbci	r31, 0xFF	; 255
 630:	90 83       	st	Z, r25
 632:	0b c0       	rjmp	.+22     	; 0x64a <__vector_16+0x8c>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:216

  switch (USI_TWI_Overflow_State) {
  // ---------- Address mode ----------
  // Check address and send ACK (and next USI_SLAVE_SEND_DATA) if OK, else reset USI.
  case USI_SLAVE_CHECK_ADDRESS:
    if ((USIDR == 0) || ((USIDR >> 1) == TWI_slaveAddress)) {
 634:	8f b1       	in	r24, 0x0f	; 15
 636:	88 23       	and	r24, r24
 638:	19 f0       	breq	.+6      	; 0x640 <__vector_16+0x82>
 63a:	8f b1       	in	r24, 0x0f	; 15
 63c:	86 95       	lsr	r24
 63e:	71 f4       	brne	.+28     	; 0x65c <__vector_16+0x9e>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:217
      if (USIDR & 0x01) {
 640:	78 9b       	sbis	0x0f, 0	; 15
 642:	07 c0       	rjmp	.+14     	; 0x652 <__vector_16+0x94>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:224
          // reset tx buffer and call callback
          tmpTxTail = TWI_TxHead;
          TWI_TxTail = tmpTxTail;
          USI_TWI_On_Slave_Transmit();
        }
        USI_TWI_Overflow_State = USI_SLAVE_SEND_DATA;
 644:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:226
      } else {
        USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 646:	80 93 82 00 	sts	0x0082, r24	; 0x800082 <USI_TWI_Overflow_State>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:228
      }
      SET_USI_TO_SEND_ACK();
 64a:	1f b8       	out	0x0f, r1	; 15
 64c:	d6 9a       	sbi	0x1a, 6	; 26
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:302
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
 64e:	8e e7       	ldi	r24, 0x7E	; 126
 650:	21 c0       	rjmp	.+66     	; 0x694 <__vector_16+0xd6>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:226
          TWI_TxTail = tmpTxTail;
          USI_TWI_On_Slave_Transmit();
        }
        USI_TWI_Overflow_State = USI_SLAVE_SEND_DATA;
      } else {
        USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 652:	84 e0       	ldi	r24, 0x04	; 4
 654:	f8 cf       	rjmp	.-16     	; 0x646 <__vector_16+0x88>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:237
    break;

  // ----- Master write data mode ------
  // Check reply and goto USI_SLAVE_SEND_DATA if OK, else reset USI.
  case USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA:
    if (USIDR) // If NACK, the master does not want more data.
 656:	8f b1       	in	r24, 0x0f	; 15
 658:	88 23       	and	r24, r24
 65a:	21 f0       	breq	.+8      	; 0x664 <__vector_16+0xa6>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:255
    if (TWI_TxHead != tmpTxTail) {
      TWI_TxTail = (TWI_TxTail + 1) & TWI_TX_BUFFER_MASK;
      USIDR      = TWI_TxBuf[TWI_TxTail];
    } else // If the buffer is empty then:
    {
      SET_USI_TO_TWI_START_CONDITION_MODE();
 65c:	d6 98       	cbi	0x1a, 6	; 26
 65e:	88 ea       	ldi	r24, 0xA8	; 168
 660:	8d b9       	out	0x0d, r24	; 13
 662:	17 c0       	rjmp	.+46     	; 0x692 <__vector_16+0xd4>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:249
  // Copy data from buffer to USIDR and set USI to shift byte. Next USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA
  /* Falls through. */
  case USI_SLAVE_SEND_DATA:

    // Get data from Buffer
    tmpTxTail = TWI_TxTail; // Not necessary, but prevents warnings
 664:	80 91 87 00 	lds	r24, 0x0087	; 0x800087 <TWI_TxTail>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:250
    if (TWI_TxHead != tmpTxTail) {
 668:	90 91 88 00 	lds	r25, 0x0088	; 0x800088 <TWI_TxHead>
 66c:	98 17       	cp	r25, r24
 66e:	b1 f3       	breq	.-20     	; 0x65c <__vector_16+0x9e>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:251
      TWI_TxTail = (TWI_TxTail + 1) & TWI_TX_BUFFER_MASK;
 670:	80 91 87 00 	lds	r24, 0x0087	; 0x800087 <TWI_TxTail>
 674:	8f 5f       	subi	r24, 0xFF	; 255
 676:	8f 70       	andi	r24, 0x0F	; 15
 678:	80 93 87 00 	sts	0x0087, r24	; 0x800087 <TWI_TxTail>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:252
      USIDR      = TWI_TxBuf[TWI_TxTail];
 67c:	e0 91 87 00 	lds	r30, 0x0087	; 0x800087 <TWI_TxTail>
 680:	f0 e0       	ldi	r31, 0x00	; 0
 682:	e0 59       	subi	r30, 0x90	; 144
 684:	ff 4f       	sbci	r31, 0xFF	; 255
 686:	80 81       	ld	r24, Z
 688:	8f b9       	out	0x0f, r24	; 15
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:258
    } else // If the buffer is empty then:
    {
      SET_USI_TO_TWI_START_CONDITION_MODE();
      return;
    }
    USI_TWI_Overflow_State = USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA;
 68a:	82 e0       	ldi	r24, 0x02	; 2
 68c:	80 93 82 00 	sts	0x0082, r24	; 0x800082 <USI_TWI_Overflow_State>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:259
    SET_USI_TO_SEND_DATA();
 690:	d6 9a       	sbi	0x1a, 6	; 26
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:272

  // ----- Master read data mode ------
  // Set USI to sample data from master. Next USI_SLAVE_GET_DATA_AND_SEND_ACK.
  case USI_SLAVE_REQUEST_DATA:
    USI_TWI_Overflow_State = USI_SLAVE_GET_DATA_AND_SEND_ACK;
    SET_USI_TO_READ_DATA();
 692:	80 e7       	ldi	r24, 0x70	; 112
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:302
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
 694:	8e b9       	out	0x0e, r24	; 14
 696:	a8 cf       	rjmp	.-176    	; 0x5e8 <__vector_16+0x2a>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:264
    SET_USI_TO_SEND_DATA();
    break;

  // Set USI to sample reply from master. Next USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA
  case USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA:
    USI_TWI_Overflow_State = USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA;
 698:	83 e0       	ldi	r24, 0x03	; 3
 69a:	80 93 82 00 	sts	0x0082, r24	; 0x800082 <USI_TWI_Overflow_State>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:265
    SET_USI_TO_READ_ACK();
 69e:	d6 98       	cbi	0x1a, 6	; 26
 6a0:	1f b8       	out	0x0f, r1	; 15
 6a2:	d5 cf       	rjmp	.-86     	; 0x64e <__vector_16+0x90>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:271
    break;

  // ----- Master read data mode ------
  // Set USI to sample data from master. Next USI_SLAVE_GET_DATA_AND_SEND_ACK.
  case USI_SLAVE_REQUEST_DATA:
    USI_TWI_Overflow_State = USI_SLAVE_GET_DATA_AND_SEND_ACK;
 6a4:	85 e0       	ldi	r24, 0x05	; 5
 6a6:	80 93 82 00 	sts	0x0082, r24	; 0x800082 <USI_TWI_Overflow_State>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:272
    SET_USI_TO_READ_DATA();
 6aa:	d6 98       	cbi	0x1a, 6	; 26
 6ac:	f2 cf       	rjmp	.-28     	; 0x692 <__vector_16+0xd4>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:302
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
 6ae:	d6 98       	cbi	0x1a, 6	; 26
 6b0:	ce cf       	rjmp	.-100    	; 0x64e <__vector_16+0x90>

000006b2 <__vector_15>:
__vector_15():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:165
ISR(USI_START_VECTOR)
#elif __ICCAVR__
#pragma vector = USI_START_VECTOR
__interrupt void USI_Start_Condition_ISR(void)
#endif
{
 6b2:	1f 92       	push	r1
 6b4:	0f 92       	push	r0
 6b6:	0f b6       	in	r0, 0x3f	; 63
 6b8:	0f 92       	push	r0
 6ba:	11 24       	eor	r1, r1
 6bc:	8f 93       	push	r24
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:178
      // reset rx buffer
      TWI_RxTail = tmpRxHead;
    }
  }

  USI_TWI_Overflow_State = USI_SLAVE_CHECK_ADDRESS;
 6be:	10 92 82 00 	sts	0x0082, r1	; 0x800082 <USI_TWI_Overflow_State>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:179
  DDR_USI &= ~(1 << PORT_USI_SDA); // Set SDA as input
 6c2:	d6 98       	cbi	0x1a, 6	; 26
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:180
  while ((tmpPin = (PIN_USI_CL & (1 << PORT_USI_SCL))) && ((PIN_USI & (1 << PIN_USI_SDA)) == 0))
 6c4:	cc 9b       	sbis	0x19, 4	; 25
 6c6:	04 c0       	rjmp	.+8      	; 0x6d0 <__vector_15+0x1e>
 6c8:	ce 9b       	sbis	0x19, 6	; 25
 6ca:	fc cf       	rjmp	.-8      	; 0x6c4 <__vector_15+0x12>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:185
    ; // Wait for SCL to go low to ensure the "Start Condition" has completed.
        // If a Stop condition arises then leave the interrupt to prevent waiting forever.
  if (tmpPin) {
    // Stop Condition (waiting for next Start Condition)
    USICR = (1 << USISIE) | (0 << USIOIE) | // Enable Start Condition Interrupt. Disable Overflow Interrupt.
 6cc:	88 ea       	ldi	r24, 0xA8	; 168
 6ce:	01 c0       	rjmp	.+2      	; 0x6d2 <__vector_15+0x20>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:192
                                            // to first Start Condition (potential failure)
            (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
            (0 << USITC);
  } else {
    // really Start Condition (Enable Overflow Interrupt)
    USICR = (1 << USISIE) | (1 << USIOIE)
 6d0:	88 ef       	ldi	r24, 0xF8	; 248
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:185
  while ((tmpPin = (PIN_USI_CL & (1 << PORT_USI_SCL))) && ((PIN_USI & (1 << PIN_USI_SDA)) == 0))
    ; // Wait for SCL to go low to ensure the "Start Condition" has completed.
        // If a Stop condition arises then leave the interrupt to prevent waiting forever.
  if (tmpPin) {
    // Stop Condition (waiting for next Start Condition)
    USICR = (1 << USISIE) | (0 << USIOIE) | // Enable Start Condition Interrupt. Disable Overflow Interrupt.
 6d2:	8d b9       	out	0x0d, r24	; 13
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:198
            | // Enable Overflow and Start Condition Interrupt. (Keep StartCondInt to detect RESTART)
            (1 << USIWM1) | (1 << USIWM0) |                 // Set USI in Two-wire mode.
            (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
            (0 << USITC);
  }
  USISR = (1 << USI_START_COND_INT) | (1 << USIOIF) | (1 << USIPF) | (1 << USIDC) | // Clear flags
 6d4:	80 ef       	ldi	r24, 0xF0	; 240
 6d6:	8e b9       	out	0x0e, r24	; 14
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:200
          (0x0 << USICNT0); // Set USI to sample 8 bits i.e. count 16 external pin toggles.
}
 6d8:	8f 91       	pop	r24
 6da:	0f 90       	pop	r0
 6dc:	0f be       	out	0x3f, r0	; 63
 6de:	0f 90       	pop	r0
 6e0:	1f 90       	pop	r1
 6e2:	18 95       	reti

000006e4 <main>:
main():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1138
*/

  // Use the Millis Timer for fast PWM (unless it doesn't have an output).
  #if (TIMER_TO_USE_FOR_MILLIS == 0)
    #if defined(WGM01) // if Timer0 has PWM
      TCCR0A = (1<<WGM01) | (1<<WGM00);
 6e4:	83 e0       	ldi	r24, 0x03	; 3
 6e6:	80 bf       	out	0x30, r24	; 48
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1141
    #endif
    #if defined(TCCR0B) //The x61 has a wacky Timer0!
      TCCR0B = (MillisTimer_Prescale_Index << CS00);
 6e8:	83 bf       	out	0x33, r24	; 51
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1162
    TCCR1A = 1<<WGM10;
    TCCR1B = (1<<WGM12) | (MillisTimer_Prescale_Index << CS10);
  #endif

  // this needs to be called before setup() or some functions won't work there
  sei();
 6ea:	78 94       	sei
initToneTimerInternal():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:972
    #elif (TIMER_TO_USE_FOR_TONE == 1 ) && defined(__AVR_ATtinyX7__)
      TCCR1A = (1<<COM1A1)|(1<<COM1B1)|(1<<WGM10);
      TCCR1B = (ToneTimer_Prescale_Index << CS10);
    #elif (TIMER_TO_USE_FOR_TONE == 1) // x4, x8, x313,
      // Use the Tone Timer for phase correct PWM
      TCCR1A = (1<<WGM10);
 6ec:	91 e0       	ldi	r25, 0x01	; 1
 6ee:	9f bd       	out	0x2f, r25	; 47
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:973
      TCCR1B = (0<<WGM12) | (0<<WGM13) | (ToneTimer_Prescale_Index << CS10); //set the clock
 6f0:	8e bd       	out	0x2e, r24	; 46
main():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1214
  #if defined( INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER ) && INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER
    #if defined(ADCSRA)
      // set a2d prescale factor
      // ADCSRA = (ADCSRA & ~((1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0))) | (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
      // dude, this is being called on startup. We know that ADCSRA is 0! Why add a RMW cycle?!
      ADCSRA = (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
 6f2:	86 e8       	ldi	r24, 0x86	; 134
 6f4:	86 b9       	out	0x06, r24	; 6
setupBoard():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/board.cpp:16
  // LL -| B2/8      A3/3 |- RD
  // LD -| A7/7    A4/SCL |-
  //    -| A6/SDA A5/OC1B |- Buzzer
  //     ------------------
  // thus the data directions are:
  DDRA = (1 << PORTA4) | (1 << PORTA5) | (1 << PORTA6);
 6f6:	80 e7       	ldi	r24, 0x70	; 112
 6f8:	8a bb       	out	0x1a, r24	; 26
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/board.cpp:17
  DDRB = 0;
 6fa:	17 ba       	out	0x17, r1	; 23
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/board.cpp:19
  // pull up on the joystick pins
  PORTA |= (1 << PORTA7) | (1 << PORTA3) | (1 << PORTA2) | (1 << PORTA1) | (1 << PORTA0);
 6fc:	8b b3       	in	r24, 0x1b	; 27
 6fe:	8f 68       	ori	r24, 0x8F	; 143
 700:	8b bb       	out	0x1b, r24	; 27
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/board.cpp:20
  PORTB |= (1 << PORTB2) | (1 << PORTB1) | (1 << PORTB0);
 702:	88 b3       	in	r24, 0x18	; 24
 704:	87 60       	ori	r24, 0x07	; 7
 706:	88 bb       	out	0x18, r24	; 24
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/board.cpp:23

  // output on OC1B
  TCCR1A = (1 << COM1B0);
 708:	80 e1       	ldi	r24, 0x10	; 16
 70a:	8f bd       	out	0x2f, r24	; 47
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/board.cpp:25
  // CTC (clear on OCR1A)
  TCCR1B = (1 << WGM12);
 70c:	88 e0       	ldi	r24, 0x08	; 8
 70e:	8e bd       	out	0x2e, r24	; 46
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/board.cpp:27

  sei();
 710:	78 94       	sei
begin():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:364
}

// Public Methods //////////////////////////////////////////////////////////////

void TwoWire::begin(void) {
  BufferIndex = 0;
 712:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <TwoWire::BufferIndex>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:365
  BufferLength = 0;
 716:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <TwoWire::BufferLength>
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:367

  transmitting = 0;
 71a:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <TwoWire::transmitting>
USI_TWI_Master_Initialise():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:61
{
  #ifdef PUE_USI
  PUE_USI |=(1 << PIN_USI_SDA);
  PUE_USI_CL |=(1 << PIN_USI_SCL);
  #endif
  PORT_USI |= (1 << PIN_USI_SDA); // Enable pullup on SDA, to set high as released state.
 71e:	de 9a       	sbi	0x1b, 6	; 27
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:62
  PORT_USI_CL |= (1 << PIN_USI_SCL); // Enable pullup on SCL, to set high as released state.
 720:	dc 9a       	sbi	0x1b, 4	; 27
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:64

  DDR_USI_CL |= (1 << PIN_USI_SCL); // Enable SCL as output.
 722:	d4 9a       	sbi	0x1a, 4	; 26
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:65
  DDR_USI |= (1 << PIN_USI_SDA); // Enable SDA as output.
 724:	d6 9a       	sbi	0x1a, 6	; 26
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:67

  USIDR = 0xFF;                                           // Preload dataregister with "released level" data.
 726:	8f ef       	ldi	r24, 0xFF	; 255
 728:	8f b9       	out	0x0f, r24	; 15
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:68
  USICR = (0 << USISIE) | (0 << USIOIE) |                 // Disable Interrupts.
 72a:	8a e2       	ldi	r24, 0x2A	; 42
 72c:	8d b9       	out	0x0d, r24	; 13
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:72
          (1 << USIWM1) | (0 << USIWM0) |                 // Set USI in Two-wire mode.
          (1 << USICS1) | (0 << USICS0) | (1 << USICLK) | // Software stobe as counter clock source
          (0 << USITC);
  USISR = (1 << USISIF) | (1 << USIOIF) | (1 << USIPF) | (1 << USIDC) | // Clear flags,
 72e:	80 ef       	ldi	r24, 0xF0	; 240
 730:	8e b9       	out	0x0e, r24	; 14
 732:	10 eb       	ldi	r17, 0xB0	; 176
beginTransmission():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:471
  BufferIndex = 1; // reserved by slave address
  BufferLength = BufferIndex;
}

void TwoWire::beginTransmission(int address) {
  beginTransmission((uint8_t)address);
 734:	8c e3       	ldi	r24, 0x3C	; 60
 736:	ed dd       	rcall	.-1062   	; 0x312 <TwoWire::beginTransmission(unsigned char) [clone .constprop.6]>
ClearDisplay():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:165
}

void ClearDisplay() {
  for (int p = 0; p < 8; p++) {
    Wire.beginTransmission(address);
    Single(0xB0 + p);
 738:	81 2f       	mov	r24, r17
 73a:	9d de       	rcall	.-710    	; 0x476 <Single(unsigned char)>
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:166
    Wire.endTransmission();
 73c:	7c de       	rcall	.-776    	; 0x436 <TwoWire::endTransmission() [clone .constprop.9]>
 73e:	c8 e0       	ldi	r28, 0x08	; 8
 740:	d0 e0       	ldi	r29, 0x00	; 0
beginTransmission():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:471
 742:	8c e3       	ldi	r24, 0x3C	; 60
 744:	e6 dd       	rcall	.-1076   	; 0x312 <TwoWire::beginTransmission(unsigned char) [clone .constprop.6]>
ClearDisplay():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:169
    for (int q = 0; q < 8; q++) {
      Wire.beginTransmission(address);
      Wire.write(data);
 746:	80 e4       	ldi	r24, 0x40	; 64
 748:	90 e0       	ldi	r25, 0x00	; 0
 74a:	e2 dd       	rcall	.-1084   	; 0x310 <TwoWire::write(int) [clone .constprop.7]>
 74c:	a4 e1       	ldi	r26, 0x14	; 20
 74e:	ea 2e       	mov	r14, r26
 750:	f1 2c       	mov	r15, r1
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:170
      for (int i = 0; i < 20; i++) Wire.write(0);
 752:	90 e0       	ldi	r25, 0x00	; 0
 754:	80 e0       	ldi	r24, 0x00	; 0
 756:	dc dd       	rcall	.-1096   	; 0x310 <TwoWire::write(int) [clone .constprop.7]>
 758:	81 e0       	ldi	r24, 0x01	; 1
 75a:	e8 1a       	sub	r14, r24
 75c:	f1 08       	sbc	r15, r1
 75e:	c9 f7       	brne	.-14     	; 0x752 <main+0x6e>
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:171
      Wire.endTransmission();
 760:	6a de       	rcall	.-812    	; 0x436 <TwoWire::endTransmission() [clone .constprop.9]>
 762:	21 97       	sbiw	r28, 0x01	; 1
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:167
void ClearDisplay() {
  for (int p = 0; p < 8; p++) {
    Wire.beginTransmission(address);
    Single(0xB0 + p);
    Wire.endTransmission();
    for (int q = 0; q < 8; q++) {
 764:	71 f7       	brne	.-36     	; 0x742 <main+0x5e>
 766:	1f 5f       	subi	r17, 0xFF	; 255
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:163
  Wire.write(0xAF);  // Display on
  Wire.endTransmission();
}

void ClearDisplay() {
  for (int p = 0; p < 8; p++) {
 768:	18 3b       	cpi	r17, 0xB8	; 184
 76a:	21 f7       	brne	.-56     	; 0x734 <main+0x50>
beginTransmission():
C:\Users\person\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:471
 76c:	8c e3       	ldi	r24, 0x3C	; 60
 76e:	d1 dd       	rcall	.-1118   	; 0x312 <TwoWire::beginTransmission(unsigned char) [clone .constprop.6]>
InitDisplay():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:156
  Wire.begin();
}

void InitDisplay() {
  Wire.beginTransmission(address);
  Wire.write(commands);
 770:	90 e0       	ldi	r25, 0x00	; 0
 772:	80 e0       	ldi	r24, 0x00	; 0
 774:	cd dd       	rcall	.-1126   	; 0x310 <TwoWire::write(int) [clone .constprop.7]>
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:157
  Wire.write(0xA1);  // Flip horizontal
 776:	81 ea       	ldi	r24, 0xA1	; 161
 778:	90 e0       	ldi	r25, 0x00	; 0
 77a:	ca dd       	rcall	.-1132   	; 0x310 <TwoWire::write(int) [clone .constprop.7]>
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:158
  Wire.write(0xAF);  // Display on
 77c:	8f ea       	ldi	r24, 0xAF	; 175
 77e:	90 e0       	ldi	r25, 0x00	; 0
 780:	c7 dd       	rcall	.-1138   	; 0x310 <TwoWire::write(int) [clone .constprop.7]>
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:159
  Wire.endTransmission();
 782:	59 de       	rcall	.-846    	; 0x436 <TwoWire::endTransmission() [clone .constprop.9]>
MoveTo():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:203
  Wire.endTransmission();
}

// Move current plot position to x,y
void MoveTo(int x, int y) {
  x0 = x;
 784:	82 e1       	ldi	r24, 0x12	; 18
 786:	90 e0       	ldi	r25, 0x00	; 0
 788:	90 93 86 00 	sts	0x0086, r25	; 0x800086 <x0+0x1>
 78c:	80 93 85 00 	sts	0x0085, r24	; 0x800085 <x0>
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:204
  y0 = y;
 790:	80 e3       	ldi	r24, 0x30	; 48
 792:	90 e0       	ldi	r25, 0x00	; 0
 794:	90 93 84 00 	sts	0x0084, r25	; 0x800084 <y0+0x1>
 798:	80 93 83 00 	sts	0x0083, r24	; 0x800083 <y0>
debugStack():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/debug-modes.cpp:174
  // kill tail call optimization
}

void debugStack(){
  MoveTo(18, 48);
  PlotText(PSTR("STACK SIZE TEST"));
 79c:	87 e7       	ldi	r24, 0x77	; 119
 79e:	92 e0       	ldi	r25, 0x02	; 2
 7a0:	72 de       	rcall	.-796    	; 0x486 <PlotText(char const*)>
MoveTo():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:203
  Wire.endTransmission();
}

// Move current plot position to x,y
void MoveTo(int x, int y) {
  x0 = x;
 7a2:	89 e0       	ldi	r24, 0x09	; 9
 7a4:	90 e0       	ldi	r25, 0x00	; 0
 7a6:	90 93 86 00 	sts	0x0086, r25	; 0x800086 <x0+0x1>
 7aa:	80 93 85 00 	sts	0x0085, r24	; 0x800085 <x0>
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:204
  y0 = y;
 7ae:	88 e2       	ldi	r24, 0x28	; 40
 7b0:	90 e0       	ldi	r25, 0x00	; 0
 7b2:	90 93 84 00 	sts	0x0084, r25	; 0x800084 <y0+0x1>
 7b6:	80 93 83 00 	sts	0x0083, r24	; 0x800083 <y0>
debugStack():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/debug-modes.cpp:176
  MoveTo(9, 40);
  PlotText(PSTR("PRESS ANY FOR AN A"));
 7ba:	84 e6       	ldi	r24, 0x64	; 100
 7bc:	92 e0       	ldi	r25, 0x02	; 2
 7be:	63 de       	rcall	.-826    	; 0x486 <PlotText(char const*)>
MoveTo():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:203
  Wire.endTransmission();
}

// Move current plot position to x,y
void MoveTo(int x, int y) {
  x0 = x;
 7c0:	d0 93 86 00 	sts	0x0086, r29	; 0x800086 <x0+0x1>
 7c4:	c0 93 85 00 	sts	0x0085, r28	; 0x800085 <x0>
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/sh1106.cpp:204
  y0 = y;
 7c8:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <y0+0x1>
 7cc:	10 92 83 00 	sts	0x0083, r1	; 0x800083 <y0>
testStack():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/debug-modes.cpp:164
}

// how deep can you go? stack frame must contain a 4B param so this doesn't take forever
void testStack(uint32_t x){
  MoveTo(x,0);
  PlotText(PSTR("A"));
 7d0:	82 e6       	ldi	r24, 0x62	; 98
 7d2:	92 e0       	ldi	r25, 0x02	; 2
 7d4:	58 de       	rcall	.-848    	; 0x486 <PlotText(char const*)>
getJoystickState():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/board.cpp:36
// cram the 8 bits (high = direction pushed) into 1 return byte
// with order: msb- LD LR LU LL RD RR RU RL -lsb
uint8_t getJoystickState() {
  // remember that joystick pins are active low so invert too to get active directions
  //   and that A4, A6 are SPI pins, and A5 is the buzzer! So mask those out of pinA!!
  uint8_t pinA = PINA & ~(1 << PORTA6 | 1 << PORTA5 | 1 << PORTA4) , pinB = PINB;
 7d6:	49 b3       	in	r20, 0x19	; 25
 7d8:	26 b3       	in	r18, 0x16	; 22
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/board.cpp:37
  return ~(pinA | ((pinB & (1 << PORTB0)) << 6) | ((pinB & (1 << PORTB1)) << 4) | ((pinB & (1 << PORTB2)) << 2));
 7da:	30 e0       	ldi	r19, 0x00	; 0
 7dc:	c9 01       	movw	r24, r18
 7de:	56 e0       	ldi	r21, 0x06	; 6
 7e0:	88 0f       	add	r24, r24
 7e2:	99 1f       	adc	r25, r25
 7e4:	5a 95       	dec	r21
 7e6:	e1 f7       	brne	.-8      	; 0x7e0 <main+0xfc>
 7e8:	80 74       	andi	r24, 0x40	; 64
 7ea:	b9 01       	movw	r22, r18
 7ec:	e4 e0       	ldi	r30, 0x04	; 4
 7ee:	66 0f       	add	r22, r22
 7f0:	77 1f       	adc	r23, r23
 7f2:	ea 95       	dec	r30
 7f4:	e1 f7       	brne	.-8      	; 0x7ee <main+0x10a>
 7f6:	60 72       	andi	r22, 0x20	; 32
 7f8:	86 2b       	or	r24, r22
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/board.cpp:36
// cram the 8 bits (high = direction pushed) into 1 return byte
// with order: msb- LD LR LU LL RD RR RU RL -lsb
uint8_t getJoystickState() {
  // remember that joystick pins are active low so invert too to get active directions
  //   and that A4, A6 are SPI pins, and A5 is the buzzer! So mask those out of pinA!!
  uint8_t pinA = PINA & ~(1 << PORTA6 | 1 << PORTA5 | 1 << PORTA4) , pinB = PINB;
 7fa:	4f 78       	andi	r20, 0x8F	; 143
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/board.cpp:37
  return ~(pinA | ((pinB & (1 << PORTB0)) << 6) | ((pinB & (1 << PORTB1)) << 4) | ((pinB & (1 << PORTB2)) << 2));
 7fc:	84 2b       	or	r24, r20
 7fe:	22 0f       	add	r18, r18
 800:	33 1f       	adc	r19, r19
 802:	22 0f       	add	r18, r18
 804:	33 1f       	adc	r19, r19
 806:	20 71       	andi	r18, 0x10	; 16
 808:	82 2b       	or	r24, r18
testStack():
C:\Users\person\fleet\tiny-dungeon\tiny-dungeon/debug-modes.cpp:165
  while (getJoystickState() == 0){}
 80a:	8f 3f       	cpi	r24, 0xFF	; 255
 80c:	21 f3       	breq	.-56     	; 0x7d6 <main+0xf2>
 80e:	21 96       	adiw	r28, 0x01	; 1
 810:	d7 cf       	rjmp	.-82     	; 0x7c0 <main+0xdc>

00000812 <__mulhi3>:
__mulhi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:312
 812:	00 24       	eor	r0, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:313
 814:	55 27       	eor	r21, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:314
 816:	04 c0       	rjmp	.+8      	; 0x820 <__mulhi3+0xe>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:317
 818:	08 0e       	add	r0, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:318
 81a:	59 1f       	adc	r21, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:320
 81c:	88 0f       	add	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:321
 81e:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:324
 820:	00 97       	sbiw	r24, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:325
 822:	29 f0       	breq	.+10     	; 0x82e <__mulhi3+0x1c>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:328
 824:	76 95       	lsr	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:329
 826:	67 95       	ror	r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:331
 828:	b8 f3       	brcs	.-18     	; 0x818 <__mulhi3+0x6>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:335
 82a:	71 05       	cpc	r23, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:337
 82c:	b9 f7       	brne	.-18     	; 0x81c <__mulhi3+0xa>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:340
 82e:	80 2d       	mov	r24, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:341
 830:	95 2f       	mov	r25, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:342
 832:	08 95       	ret

00000834 <_exit>:
exit():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 834:	f8 94       	cli

00000836 <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 836:	ff cf       	rjmp	.-2      	; 0x836 <__stop_program>
